<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>80</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Room handler object

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Map data
// Map represented by string (used to build the tiles / map)
tilesRaw = -1;

// Tile grid : ds_grid representing the tiles
tiles = -1;
tilesWid = 0;
tilesHei = 0;

// Player spawners : list of cells position that player can spawn on
tilesPlayerspawners = -1;

// Flavour text : random meaningless text
flavourText = "PAIN ROOM";

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Map draw data
// Map's mesh (in vertex buffer)
tilesVB = vertex_create_buffer();

// How tall is the wall should be?
tilesWallHeight = 16;

// Is map's mesh ready to draw?
tilesVBReady = false;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Debug / Draw related
// Whether or not to draw the tiles
debugDrawMap = false;
debugDrawMapCellSize = 32; // size of each cell / tiles
debugDrawMapCellScale = debugDrawMapCellSize / GFX_TILE_SIZE;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Roll &amp; Build flavour text
flavourText = generate_flavour_text();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Build room's vertex buffer for drawing
debug_trace("BUILDING ROOM MESH...");
// Recreate tiles vertex buffer
vertex_delete_buffer(tilesVB);
tilesVB = vertex_create_buffer();

room_build_mesh(tilesVB);
tilesVBReady = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Generate room from array of "map strings" stored in variable
debug_trace("GENERATING ROOM FROM MAP STRING...");

// (destroy previous tiles data)
if (ds_exists(tiles, ds_type_grid))
{
    ds_grid_destroy(tiles);
    tiles = -1;
}
if (ds_exists(tilesPlayerspawners, ds_type_list))
{
    ds_list_destroy(tilesPlayerspawners);
    tilesPlayerspawners = -1;
}

// Build map grid from string data
tiles = map_from_string_arr(tilesRaw);
tilesWid = ds_grid_width(tiles);
tilesHei = ds_grid_height(tiles);

// Analyze room
// Place objects according to tile types
for (var _x=0; _x&lt;tilesWid; _x++)
{
    for (var _y=0; _y&lt;tilesHei; _y++)
    {
        var _tileinfo   = global.TILE_INFO[@ tiles[# _x, _y]];
        var _tileobj    = _tileinfo[@ eTILE_INFO.OBJ];
        if (_tileobj != -1)
        {
            var _objx = _x * GFX_TILE_SIZE + _tileinfo[@ eTILE_INFO.OBJ_X];
            var _objy = _y * GFX_TILE_SIZE + _tileinfo[@ eTILE_INFO.OBJ_Y];
            instance_create(_objx, _objy, _tileobj);
        }
    }
}

// Find the tiles that players can spawn
tilesPlayerspawners = ds_list_create();
for (var _x=0; _x&lt;tilesWid; _x++)
{
    for (var _y=0; _y&lt;tilesHei; _y++)
    {
        var _tile = tiles[# _x, _y];
        
        if (_tile == eTILE.SPAWN_PLR)
        {
            ds_list_add(tilesPlayerspawners, makearray(_x, _y));
        }
    }
}

// Give a random mob in a map a key for weapon
var _mobnum = instance_number(oEnemy);
var _randommob = instance_find(oEnemy, irandom_range(0, _mobnum - 1));
if (_mobnum &gt; 0 &amp;&amp; instance_exists(_randommob))
{
    weapon_replace(_randommob, generate_weapon_key());
}
else
{
    // NO mob? Then unlock all doors for safety measures
    with (oDoor)
    {
        event_user(3);
    }
}

// Update map's mesh
event_user(1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the tiles on GUI if needed
if (debugDrawMap)
{
    // Fetch tile grid's width / height &amp; calculate values used for drawing
    var _wid = tilesWid;
    var _hei = tilesHei;
    // (final width and height of map in pixels)
    var _mapwid = _wid * debugDrawMapCellSize;
    var _maphei = _hei * debugDrawMapCellSize;
    
    // Initialize variables for drawing offsets
    var _mapx = (window_get_width() - _mapwid) * 0.5;
    var _mapy = (window_get_height() - _maphei) * 0.5;

    // 1] Tiles : Iterate through all the tiles in grid &amp; draw them
    for (var _x=0; _x&lt;_wid; _x++)
    {
        for (var _y=0; _y&lt;_hei; _y++)
        {
            var _index = global.TILE_INFO[@ tiles[# _x, _y]];
            
            // (calculate the final position to draw sprite on)
            var _drawx = _mapx + _x * debugDrawMapCellSize;
            var _drawy = _mapy + _y * debugDrawMapCellSize;
            
            // (calculate the blit coords / pixel space uv of sprite from index)
            var _u = _index[@ 0] * GFX_TILE_SIZE;
            var _v = _index[@ 1] * GFX_TILE_SIZE;
            
            // (blit &amp; draw sprite using the calculated values)
            draw_sprite_part_ext(sprTexture, 0, _u, _v, GFX_TILE_SIZE, GFX_TILE_SIZE, _drawx, _drawy, debugDrawMapCellScale, debugDrawMapCellScale, c_white, 1.0);
        }
    }
    
    // 2] Entities : Draw player n' stuffs
    var _cellscale  = debugDrawMapCellScale;
    var _cellsize   = debugDrawMapCellSize;
    
    // Draw currently highlighted player spawn point
    if (!instance_exists(oPlayer) &amp;&amp; ds_list_size(tilesPlayerspawners) &gt; 0)
    {
        var _currentspawner = tilesPlayerspawners[| oControl.roomPlayerSpawnIdx];
        
        // (calculate the final position to draw sprite on)
        var _drawx = _mapx + _currentspawner[@ 0] * _cellsize;
        var _drawy = _mapy + _currentspawner[@ 1] * _cellsize;
        
        // (calculate the blit coords / pixel space uv of sprite from tile index)
        var _u = (GFX_PLRSPAWN_TILE_IDX % GFX_TILE_WID) * GFX_TILE_SIZE;
        var _v = floor(GFX_PLRSPAWN_TILE_IDX / GFX_TILE_WID) * GFX_TILE_SIZE;
        
        // (calculate flashing colour)
        var _colour = merge_color(c_green, c_lime, sin(current_time * 0.001 * 2 * pi) * 0.5 + 0.5);
        draw_sprite_part_ext(sprTexture, 0, _u, _v, GFX_TILE_SIZE, GFX_TILE_SIZE, _drawx, _drawy, _cellscale, _cellscale, _colour, 1.0);
    }
    
    // Draw camera
    with (oCamera)
    {
        // (calculate offseted coords)
        var _realx = _mapx + x * _cellscale;
        var _realy = _mapy + y * _cellscale;

        // (draw direction indicator)
        var _arrowlen = 3 * _cellsize;
        draw_line(_realx, _realy, _realx + vecFx * _arrowlen, _realy + vecFy * _arrowlen);
        draw_line_color(_realx, _realy, _realx + vecRx * _arrowlen, _realy + vecRy * _arrowlen, c_red, c_red);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw the tiles
// Iterate through all the tiles in grid &amp; draw 
/*
for (var _x=0; _x&lt;tilesWid; _x++)
{
    for (var _y=0; _y&lt;tilesHei; _y++)
    {
        var _index = global.TILE_GFX_IDX[@ tiles[# _x, _y]];
        
        // (calculate the final position to draw sprite on)
        var _drawx = _x * GFX_TILE_SIZE;
        var _drawy =  _y * GFX_TILE_SIZE;
        
        // (calculate the blit coords / pixel space uv of sprite from index)
        var _u = (_index % GFX_TILE_WID) * GFX_TILE_SIZE;
        var _v = floor(_index / GFX_TILE_WID) * GFX_TILE_SIZE;
        
        // (blit &amp; draw sprite using the calculated values)
        draw_sprite_part_ext(sprTexture, 0, _u, _v, GFX_TILE_SIZE, GFX_TILE_SIZE, _drawx, _drawy, 1, 1, c_white, 1.0);
    }
}
*/

// Request to draw vertex buffer
if (tilesVBReady)
{
    ds_list_add(oRenderMan.requestVBs, tilesVB);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
